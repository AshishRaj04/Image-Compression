# -*- coding: utf-8 -*-
"""ImageCompression.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14kGhi1aM4SO0gTqNogiFpAqYHAvW8_jS
"""

# ! mkdir image/

# from google.colab import files
# uploaded = files.upload()

# ! mv bird.png image/

import matplotlib.pyplot as plt

original_image = plt.imread("image/bird.png")

plt.imshow(original_image)

print("The shape of the image is: ",original_image.shape)

import numpy as np

X_img = np.reshape(original_image , (original_image.shape[0] * original_image.shape[1] , original_image.shape[2]))

X_img.shape

def nearest_centroid(X , centroid):
  k = centroid.shape[0]
  c = np.zeros(X.shape[0] , dtype=int)

  for i in range(X.shape[0]):
    distance = []
    for j in range(k):
      norm_ij = np.linalg.norm(X[i] - centroid[j])
      distance.append(norm_ij)
    c[i] = np.argmin(distance)
  return c

def compute_centroid(X , c , k):
  m , n = X.shape
  centroids = np.zeros((k , n))
  for i in range(k):
    centroids[i] = np.mean(X[c == i] , axis = 0)
  return centroids

def initialize_centroid(X , k):
  random_index = np.random.permutation(X.shape[0])
  return X[random_index[:k]]

from matplotlib.colors import ListedColormap

def plot_data_points(X, idx):
    # Define colormap to match Figure 1 in the notebook
    cmap = ListedColormap(["red", "green", "blue"])
    c = cmap(idx)

    # plots data points in X, coloring them so that those with the same
    # index assignments in idx have the same color
    plt.scatter(X[:, 0], X[:, 1], facecolors='none', edgecolors=c, linewidth=0.1, alpha=0.7)

def draw_line(p1, p2, style="-k", linewidth=1):
    plt.plot([p1[0], p2[0]], [p1[1], p2[1]], style, linewidth=linewidth)

def plot_progress_kMeans(X, centroids, previous_centroids, idx, K, i):
    # Plot the examples
    plot_data_points(X, idx)

    # Plot the centroids as black 'x's
    plt.scatter(centroids[:, 0], centroids[:, 1], marker='x', c='k', linewidths=3)

    # Plot history of the centroids with lines
    for j in range(centroids.shape[0]):
        draw_line(centroids[j, :], previous_centroids[j, :])

    plt.title("Iteration number %d" %i)

def run_kMeans(X, initial_centroids, iter, plot_progress=False):


    # Initialize values
    m, n = X.shape
    k = initial_centroids.shape[0]
    centroids = initial_centroids
    previous_centroids = centroids
    idx = np.zeros(m)
    plt.figure(figsize=(8, 6))

    # Run K-Means
    for i in range(iter):

        #Output progress
        print("K-Means iteration %d/%d" % (i, iter-1))

        # For each example in X, assign it to the closest centroid
        idx = nearest_centroid(X, centroids)

        # Optionally plot progress
        if plot_progress:
            plot_progress_kMeans(X, centroids, previous_centroids, idx, k, i)
            previous_centroids = centroids

        # Given the memberships, compute new centroids
        centroids = compute_centroid(X, idx, k)
    plt.show()
    return centroids, idx

k = 16
iter = 50
initial_centroids = initialize_centroid(X_img , k)
centroids , c = run_kMeans(X_img , initial_centroids , iter )

print("The shape of the centroid is: ",centroids.shape)
print("The shape of c is: ",c.shape)
print("The first 10 data points are associated of these centroids: ",c[:10])

def show_centroid_colors(centroids):
    palette = np.expand_dims(centroids, axis=0)
    num = np.arange(0,len(centroids))
    plt.figure(figsize=(16, 16))
    plt.xticks(num)
    plt.yticks([])
    plt.imshow(palette)

show_centroid_colors(centroids)

c = nearest_centroid(X_img , centroids)
X_recovered = centroids[c, :]
X_recovered = np.reshape(X_recovered , (original_image.shape[0] , original_image.shape[1] , original_image.shape[2]))

# Display original image
fig, ax = plt.subplots(1,2, figsize=(16,16))
plt.axis('off')

ax[0].imshow(original_image)
ax[0].set_title('Original')
ax[0].set_axis_off()


# Display compressed image
ax[1].imshow(X_recovered)
ax[1].set_title('Compressed')
ax[1].set_axis_off()

